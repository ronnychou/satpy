#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2023 Satpy developers
#
# This file is part of satpy.
#
# satpy is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# satpy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# satpy.  If not, see <http://www.gnu.org/licenses/>.

"""Reader for AGRI L2 products.

These products are generated by the NOAA enterprise cloud suite and have filenames like:
AHI-CMSK_v1r1_h09_s202308240540213_e202308240549407_c202308240557548.nc

The second letter grouping (CMSK above) indicates the product type:
    CMSK - Cloud mask

    CHGT - Cloud height

    CPHS - Cloud type and phase

These products are generated from the AHI sensor on Himawari-8 and Himawari-9, and are
produced at the native instrument resolution for the IR channels (2km at nadir).

NOTE: This reader is currently only compatible with full disk scenes. Unlike level 1 himawari
data, the netCDF files do not contain the required metadata to produce an appropriate area
definition for the data contents, and hence the area definition is hardcoded into the reader.

A warning is displayed to the user highlighting this. The assumed area definition is a full
disk image at the nominal subsatellite longitude of 140.7 degrees East.

All the simple data products are supported here, but multidimensional products are not yet
supported. These include the CldHgtFlag and the CloudMaskPacked variables.
"""

import datetime as dt
import logging

import numpy as np
import xarray as xr

from satpy._compat import cached_property
from satpy.readers.core._geos_area import get_area_definition, get_area_extent
from satpy.readers.core.file_handlers import BaseFileHandler

logger = logging.getLogger(__name__)

EXPECTED_DATA_AREA = "Full Disk"


class NC_AGRI_L2(BaseFileHandler):
    """File handler for AGRI L2 data in netCDF format."""

    def __init__(self, filename, filename_info, filetype_info):
        """Initialize the reader."""
        super().__init__(filename, filename_info, filetype_info)
        self.nc = xr.open_dataset(
            self.filename,
            decode_cf=True,
            mask_and_scale=True,
            chunks={"x": "auto", "y": "auto"}
        )

        # Check that file is a full disk scene, we don't know the area for anything else
        self.filename_info = filename_info
        self.sensor = self.nc.attrs["instrument_ID"]
        self.nlines = self.nc.sizes["x"]
        self.ncols = self.nc.sizes["y"]
        self.platform_id = self.nc.attrs["platform_ID"]
        self._meta = None
        
    @property
    def start_time(self):
        """Start timestamp of the dataset."""
        # return self.filename_info["start_time"]
        date_str = self.nc.attrs["time_coverage_start"]
        return dt.datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%S.%fZ")

    @property
    def end_time(self):
        """End timestamp of the dataset."""
        # return self.filename_info["end_time"]
        date_str = self.nc.attrs["time_coverage_end"]
        return dt.datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%S.%fZ")


    def get_dataset(self, key, info):
        """Load a dataset."""
        # key: DataID
        var = info["file_key"]
        logger.debug("Reading in get_dataset %s.", var)
        variable:xr.DataArray = self.nc[var]
        # It may be a bug that the x and y index coordinates are swapped in the AGRI L2 data
        variable = variable.rename({"x": "y", "y": "x"})
        if key['name'] != 'DQF':
            desc:str = variable.attrs['Description']
            attrs = {item.split(':')[1]: int(item.split(':')[0]) for item in desc.split(',')}
            variable = variable.where(variable!=attrs['Space'], np.nan)
            variable = variable.where(variable!=attrs['FillValue'], np.nan)
            logger.debug("Space and FillValue are set to NaN in variable %s", var)
        else:
            pass
        variable.attrs["sensor"] = self.sensor
        variable.attrs["platform_name"] = self.platform_id
        variable.attrs["start_time"] = self.start_time
        variable.attrs["end_time"] = self.end_time
        variable.attrs.update(key.to_dict())
        
        self.adjust_attrs(variable, info)
        return variable

    
    def adjust_attrs(self, data:xr.DataArray, ds_info):
        """Adjust the attrs of the data."""
        data.attrs.update({"orbital_parameters": {
            "satellite_nominal_latitude": 0,
            "satellite_nominal_longitude": self.nc['nominal_satellite_subpoint_lon'].load().item(),
            "satellite_nominal_altitude": 35785864}
        })
        # remove attributes that could be confusing later
        data.attrs.pop("FillValue", None)
        
    @cached_property
    def area(self):
        """Get AreaDefinition representing this file's data."""
        return self.get_area_def()

    def get_area_def(self, dsid):
        logger.info("The AGRI L2 products do not have the metadata required to produce an area definition."
                    " Assuming standard FY-4 full disk projection.")

        # Basic check to ensure we're processing a full disk (4km) scene.n
        if self.nlines != 2748 or self.ncols != 2748:
            raise ValueError("Input L2 file is not a full disk FY-4 scene. Only full disk data is supported.")
        try:
            ssp_lon = self.nc["nominal_satellite_subpoint_lon"].item()
        except:
            ssp_lon = self.nc["nominal_satellite_subpoint_lon"].load().item()
        try:
            h = self.nc["nominal_satellite_height"].item()
        except:
            h = self.nc["nominal_satellite_height"].load().item()
        if h > 42000000.0:
            h -= 6378137.0
        h = 35785864
        # for 4000m resolution full-disk FY-4 data, the area definition is hardcoded
        pdict = {"cfac": 10233137.0, "lfac": 10233137.0, "coff": 1373.5 - 0 + 1, "loff": -1373.5 + 2747 + 1, "a": 6378137.0, "b": 6356752.31414,
                 "h": h, "ssp_lon": ssp_lon, "nlines": self.nlines, "ncols": self.ncols, "scandir": "N2S"}

        aex = get_area_extent(pdict)

        pdict["a_name"] = "FY4_Area"
        pdict["a_desc"] = "AGRI Full Disk area"
        pdict["p_id"] = f"FY-4"

        return get_area_definition(pdict, aex)
